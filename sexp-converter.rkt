(module sexp-converter scheme
  (require srfi/1)
  (require "juggling-core.rkt")
  
  (provide 
   sexp->pattern
   expand-sexp-stars)
  
  ; (list '- '* '* '() '-)
  ; (delay next-throw last-throw throw-list-backwards first-hand)
  
  (define (replace-item list elem new-elem)
    (cond
      ((null? list) '())
      ((equal? (car list) elem) (cons new-elem list))
      (#t (cons (car list) (replace-item (cdr list) elem new-elem)))))
  
  (define (has? lst-or-atom mem)
    (or (equal? lst-or-atom mem)
        (and (list? lst-or-atom)
             (member mem lst-or-atom))))
  
  (define (expand-sexp-stars sexp-pattern)
    (cond ((has? (car sexp-pattern) '*)
            (append (cdr sexp-pattern) (star-pattern (cdr sexp-pattern))))              
           ((has? (car sexp-pattern) '**)
            (append (cdr sexp-pattern) (twostar-pattern (cdr sexp-pattern))))
           ((has? (car sexp-pattern) '***) ; "This is incredibly serious business."
            (append (cdr sexp-pattern) (star-pattern (twostar-pattern (cdr sexp-pattern)))))
           (#t sexp-pattern)))
  
  ; For now, this is going to let hands-lst just sort of be echoed
  (define (sexp->pattern sexp-pattern beat-value dwell-value hands-lst hold-beats)   
    (sexp->pattern-internal 
     (expand-sexp-stars sexp-pattern)
     beat-value dwell-value hands-lst hold-beats))          
  
  ; Double up the pattern with all throws in and going to opposite hands - hand n + 1 % 2 in multi-hand setups
  ; This may result in flagrant errors if there are an odd number of manipulators.
  (define (star-pattern p) (map star-beat p))
  
  (define (star-beat b)
    (match b ((list-rest right-throw left-throw rest)
              (cons (star-throw left-throw) (cons (star-throw right-throw) (star-beat rest))))
      (odd-or-none odd-or-none)))
  
  (define (star-throw t)
    (match t ((list-rest height hand rest)              ; There isn't a "rest" here yet, but that's probably where throw decorations will go if they ever happen.
              (cons height (cons 
                            (if (even? hand)
                                (add1 hand)
                                (sub1 hand)) rest)))
      (rest rest)))
  
  ; Like star-pattern, except it swaps the places of jugglers one and two (and any subsequent pairs) instead of the hands of juggler one.
  (define (twostar-pattern p)
    (map twostar-beat p))
  
  (define (twostar-beat b)
    (match b ((list-rest r1-throw l1-throw r2-throw l2-throw rest)
              (append (map twostar-throw (list r2-throw l2-throw r1-throw l1-throw)) (twostar-beat rest)))
      (rest rest))) ; No or too few hands left.
  
  (define (twostar-throw t)
    (match t ((list-rest height hand rest)     
              (cons height (cons
                            (+ (remainder (+ hand 2) 4) (floor (/ hand 4))) rest)))
      (three-or-less-hands three-or-less-hands)))
  
  (define (deref-hand h lst)
    (with-handlers ((exn:fail:contract? (λ _ (error "Not enough jugglers/hands"))))
                         (list-ref lst h)))
  
  (define (sexp->pattern-internal sexp-pattern beat-value dwell-value hands-lst hold-beats)    
    (define (build-segments throw-hand-i catch-hand-i next-hand-i throw-length throw-options next-options)
      (let*
          ((throw-type
            (cond 
              ((has? throw-options 'tomahawk) 'tomahawk)
              (#t 'normal)))
           
           (next-throw-type
            (cond 
              ((has? throw-options 'tomahawk) 'tomahawk)
              (#t 'normal))))
        (cond ((and (= throw-hand-i catch-hand-i)
                    (or (<= throw-length hold-beats) ; Long dwell on at least SOME 2s. Will still look a bit funky.
                        (has? throw-options 'hold)))
               (begin 
                 (list (hold-path-segment (* beat-value throw-length) throw-hand-i '()))))
              (#t
               (let* (
                      ; In the sexp format, these will have the "correct" throw length
                      ; e.g. when they are thrown and rethrown
                      ; and these options will fix appearance by modifying the dwell holds.
                      (hurried? (has? throw-options 'hurry))                      
                      (antihurried? (has? throw-options 'antihurry))
                      
                      (dwell-length 
                       (max 0 (cond ((and hurried? antihurried?) dwell-value) ; I don't know, might happen in some autogenerated and then automodified pattern...
                                    (hurried? (- dwell-value beat-value))
                                    (antihurried? (+ dwell-value beat-value))
                                    (#t dwell-value))))
                      (toss-length (- (* beat-value throw-length) dwell-length)) 
                     ) 
                 (list    
                  (ball-toss-path-segment 
                   toss-length
                   throw-hand-i catch-hand-i
                   `((throw-type ,throw-type)))
                  (dwell-hold-path-segment dwell-length catch-hand-i throw-hand-i next-hand-i
                                           `((throw-type ,throw-type))
                                           `((throw-type ,next-throw-type)))))))))
    
    ; Update objects, tacking on throw length and destination
    (define (start-object objects starting-object current-throw time current-hand)
      (let ((new-object
             (list time ; delay
                   current-throw ; next-throw, counted down
                   current-throw ; last throw, tested with eq? for identity
                   ; Each entry is from-hand to-hand height option-list
                   `((,current-hand ,(cadr current-throw) ,(car current-throw) ,(cddr current-throw)))
                   current-hand))) ; first hand, for use later
        (values #f (replace eq? objects starting-object new-object))))    
    
    (define (update-object objects object-matching-throw current-throw time current-hand)
      (match object-matching-throw 
        ((list delay next-throw last-throw throw-list first-hand)
         (if (eq? last-throw current-throw) ; circular list, so ID works... We just have to store the exact throw.                
             ; Around to the start. Don't add this throw, it matches the 1st one.
             (values #t (replace eq? objects object-matching-throw 
                                 (list delay '- last-throw throw-list first-hand)))
             ; Not the last throw. Add dwell and toss backwards, update next throw           
             (values #f 
                     (replace 
                      eq? objects object-matching-throw                              
                      (list delay current-throw last-throw 
                            (cons `(,current-hand ,(cadr current-throw) ,(car current-throw) ,(cddr current-throw)) throw-list) first-hand)))))))
    
    ; list of throw/hold segments, starting with the first throw
    ; TODO: build-segments recieves and uses PREVIOUS throw info...
    (define (build-loop-segments throw-lst)
      (let loop-throws ((throw-rest throw-lst))
        (if (null? throw-rest) '()
            (append
             (match-let 
                 (((list from-hand to-hand length options) (car throw-rest))
                  ((list _ next-hand next-length next-options) (if (null? (cdr throw-rest)) (car throw-lst) (cadr throw-rest))))
               (build-segments from-hand to-hand next-hand length options next-options))
             (loop-throws (cdr throw-rest))))))
    
    (define (trace-throws)
      ; horrible recursion...
      (let* ((c-pattern (apply circular-list sexp-pattern))
             (number-of-hands (length (car c-pattern)))
             (number-of-objects (match (ss-value sexp-pattern) ((? integer? n) n) (_ (error "Siteswap value isn't an integer.")))))
        (let loop-throws ((time 0)
                          (unfinished-objects number-of-objects)
                          (c-pattern c-pattern)
                          (objects (make-list number-of-objects (list '- '* '* '() '-)))
                          (throws-this-beat (car c-pattern))
                          (hand 0))
          (cond ((= unfinished-objects 0) ; Done: Return objects, which includes initial delay and throw lists
                 objects)
                ((null? throws-this-beat) ; Out of throw - move to next beat
                 (loop-throws (add1 time) unfinished-objects (cdr c-pattern) (advance-beat objects) (cadr c-pattern) 0))
                (#t
                 ; Process one throw against all objects.                     
                 (let* ((objects-matching-throw (match-throw objects hand)) ; Search for all objects that are up (delay of 0)
                        (unstarted-objects (match-waiting objects))                             
                        (current-throw (car throws-this-beat))
                        (value (throw-value current-throw)))
                   (cond ((> (length objects-matching-throw) 1) ; No multiplexes for now. :(
                          (error (format "Time ~a: Multiple objects met here." time)))
                         ((null? objects-matching-throw) ; No object expecting a throw
                          (if (not (eq? value '-)) 
                              ; There's a throw that no object expected.
                              (if (null? unstarted-objects)
                                  ; This COULD be a throw past the end of an object's cycle. Ugh.
                                  ; I'd like to be able to throw errors here, but I'm pretty sure that the error would show up elsewhere eventually.
                                  (loop-throws time unfinished-objects c-pattern objects (cdr throws-this-beat) (add1 hand))
                                  ; ...or start first available object.
                                  (let-values ((( finished updated-objects) 
                                                (start-object objects (car unstarted-objects) current-throw time hand)))
                                    (loop-throws time 
                                                 (if finished (sub1 unfinished-objects) unfinished-objects) 
                                                 c-pattern 
                                                 updated-objects
                                                 (cdr throws-this-beat) 
                                                 (add1 hand))))
                              
                              ; Throw not expected by any object. Continue with next hand.
                              (loop-throws time unfinished-objects c-pattern objects (cdr throws-this-beat) (add1 hand))))
                         (#t                              
                          ; Exactly one object expecting this throw.
                          (if (eq? value '-) 
                              ; There isn't a throw for the object expecting it...
                              (error (format "Time ~a: No throw for object expecting it." time))                                   
                              ; Non-zero throw value for matched object. Plenium.
                              (let-values (((finished updated-objects ) (update-object objects (car objects-matching-throw) current-throw time hand)))
                                (loop-throws time 
                                             (if finished (sub1 unfinished-objects) unfinished-objects)                                               
                                             c-pattern 
                                             updated-objects
                                             (cdr throws-this-beat) 
                                             (add1 hand))))))))))))
    
    (make-pattern
     ; Do something uncomplicated with the results of this horrible recursion...
     (map
      (λ (o)
        (match o ((list delay _ first-throw throw-lst start-hand-i)
                  (make-path-state 0 #f (cons 
                                        ; Hold until the first throw we know of...
                                        (dwell-hold-path-segment (* delay beat-value) start-hand-i start-hand-i start-hand-i '() '()) ; >_< TODO: Replace last start-hand with first destination hand...
                                        (apply circular-list 
                                               (build-loop-segments
                                                (reverse throw-lst))))))))
      (trace-throws))
     
     ; All I'm doing for movement right now is allowing h to be a path-state of a hand
     (map
      (λ (h)
        (if (path-state? h) h
            (make-path-state 0 #f
                             (circular-list
                              (make-juggler-path-segment
                               ; a long time... Doesn't really matter. Could be anything larger than about .1s.
                               100 
                                ; completely ignore the time...
                               (λ _ (λ _ h))))))) ;_;
      hands-lst)))
  
  (define (throw-value throw)
    (match throw 
      ((list-rest value hand options) value)
      ('- '-)
      ('* '-)))
  
  (define (advance-beat objects)
    (map 
     (λ (o) (match o 
              ((list delay (list-rest (? zero?) dest options) _ _ h)
               (error (format "Object starting in ~a did not reach destination hand ~a" h dest)))
              ((list delay (list-rest countdown dest options) last-throw throw-list first-hand)
               (list delay (append (list (sub1 countdown) dest) options) last-throw throw-list first-hand))
              (_ o)))                     
     objects))                     
  
  (define (match-throw objects pattern-hand)
    (filter
     (lambda (o) (match o 
                   ((list _ (list-rest countdown object-hand options)  _ _ _)
                    (and (= countdown 0) (= pattern-hand object-hand)))
                   (_ #f)))
     objects))
  
  (define (match-waiting objects)
    (filter
     (lambda (o) (match o ((list _ '* _ _ _) #t) (_ #f)))
     objects))
  
  (define (ss-value sexp-pattern)
    (/ (foldr + 0 (map car (filter pair? (apply append sexp-pattern)))) (length sexp-pattern)))
  ; buh.
  (define (replace pred lst old-elem new-elem)
    (cond
      ((null? list) '())
      ((pred old-elem (car lst)) (cons new-elem (cdr lst)))
      (#t (cons (car lst) (replace pred (cdr lst) old-elem new-elem))))))
